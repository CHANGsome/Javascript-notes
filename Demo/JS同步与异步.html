<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="x-ua-compatible" content="ie=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>JS同步与异步</title>
  </head>
  <body>
    <!--
JS是单线程的：JS就是个傻子，脑子一根筋，做着当前这件事，没有完成之前，绝对不会做下一件事情。
JS中的两种编程思想：同步、异步。

1、同步：上一件事情没有完成，继续处理上一件事，只有上一件事情完成了，才会做下一件事情（JS中大部分都是同步编程的）。
for循环就是同步编程的，只有循环结束后，才会继续执行下面的代码。
例如：
while(1){

}
console.log("ok");  //=>上面死循环，永远不会执行这行代码

2、异步：规划要做一件事情，但是不是当前立马去执行这件事情，需要等一定的事件，这样的话，我们不会等着它执行，而是继续执行下面的操作，
只有当下面的事情都处理完成了，才会返回头处理之前的事情；如果下面的事情并没有处理完成，不管之前的事情有没有到时间，都踏踏实实给我等着。
在JS中异步编程只有四种情况：
1）定时器都是异步编程的（setTimeout、setInterval）；
2）所有的事件都是异步编程的；
3）Ajax读取数据，我们一般设置为异步编程；
4）回调函数也是异步编程的。

var n = 0;
window.setTimeout(function(){
    n++;
    console.log(n); //=>1   (2)
}, 1000);
console.log(n); //=>0   (1)


// 每一个浏览器对于定时器的等待时间都有一个最小的值，谷歌：5~6ms，IE：10~13ms，
// 如果设置的等待时间小于这个值，不起作用，还是需要等到最小时间才执行的。
// 尤其是写0也不是立即执行。

var n = 0;
window.setTimeout(function(){
    n++;
    console.log(n); //=>1   (2)
}, 0);
console.log(n); //=>0   (1)


// 我们定时器设置的等待时间不一定就是最后执行的时间，如果定时器之后还有其他的事情正在处理中，不管定时器设定的时间有没有到，都是不会执行定时器里面的函数的。

var n = 0;
window.setTimeout(function(){
    n++;
    console.log(n);
}, 0);
console.log(n); //=>0   (1)
while(1){
    n++;
}
console.log(n);


// 等待时间更短的在任务队列中提前排列
var n=0;
window.setTimeout(function(){
    n+=2;
    console.log(n); //=>7   (4)
}, 20);
window.setTimeout(function(){
    n+=5;
    console.log(n);  //=>5   (3)
}, 5);
console.log(n); //=>0   (1)
for(var i=0; i<10000000;i++){

}
console.log(n); //=>0   (2)


// 事件绑定也是异步的：
例如：选项卡的事件绑定，先绑定方法，用户点击再触发事件。
-->
  </body>
</html>
